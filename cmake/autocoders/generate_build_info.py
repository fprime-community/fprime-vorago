#!/usr/bin/env python3
# Copyright 2025 California Institute of Technology
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0

###############################################################################
# cmake/autocoders/generate_build_info.py
###############################################################################

import argparse
import os
import subprocess
import sys


# this is the template for the auto-generated CPP source file
# the output path for this file is set via command-line argument
template = """\
/*
** {filename}
** This file has been autogenerated using {script}
*/

namespace Va416x0Svc {{
    namespace BuildInfo {{
        const char* DEPLOYMENT_NAME  = "{deployment_name}";
        const char* BUILD_IDENTIFIER = "{build_identifier}";
    }}
}}
"""


def parse_args(args: list[str]) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Generate deployment build information source files"
    )
    parser.add_argument(
        "target",
        help="Name of the CMake build target"
    )
    parser.add_argument(
        "output_path",
        help="Output path for the generated CPP file"
    )
    return parser.parse_args(args)


def get_project_root() -> str:
    if "FPRIME_PROJECT_ROOT" not in os.environ:
        sys.exit("ERROR: environment variable '$FPRIME_PROJECT_ROOT' is not set")
    return os.environ["FPRIME_PROJECT_ROOT"]


def get_date() -> str:
    output = subprocess.check_output(["date", "+%Y-%m-%d-%H-%M-%S"])
    return output.decode().strip()


def get_branch(project_root: str) -> str:
    output = subprocess.check_output(
        ["git", "branch", "--show-current"], cwd=project_root
    )
    branch = output.decode().strip()
    # if we are not currently on a branch (i.e. in a detached HEAD state) then fallback to the
    # current commit hash
    if not branch:
        output = subprocess.check_output(
            ["git", "rev-parse", "--short", "HEAD"], cwd=project_root
        )
        branch = output.decode().strip()
    # NOTE: enforce a maximum branch length of 20 to ensure that build identifiers can fit into
    # the maximum allowed EVR/TLM string sizes
    max_branch_len = 20
    if len(branch) > max_branch_len:
        sys.exit(
            f"ERROR: branch '{branch}' exceeds the maximum allowed length of {max_branch_len}; "
            "this limit is necessary in order to fit strings into events and telemetry"
        )
    return branch


def get_user() -> str:
    # First check if $DEVCONTAINER_HOST_USER is set, this is set for user-driven builds from
    # VS Code development containers where $USER instead defaults to root
    if "DEVCONTAINER_HOST_USER" in os.environ:
        return os.environ["DEVCONTAINER_HOST_USER"]
    # Fallback to $USER otherwise
    elif "USER" in os.environ:
        return os.environ["USER"]
    else:
        sys.exit(
            "ERROR: could not determine user, neither $DEVCONTAINER_HOST_USER nor $USER is set"
        )


def get_build_identifier(project_root: str) -> str:
    if "JENKINS_BUILD_ID" in os.environ:
        # $JENKINS_BUILD_ID can be set from the Jenkins environment to ensure unified identifiers
        # across Jenkins builds
        return os.environ["JENKINS_BUILD_ID"]
    else:
        date = get_date()
        branch = get_branch(project_root)
        user = get_user()
        return f"{date}-{branch}-dev-{user}"


def generate_source(filepath: str, deployment_name: str, build_identifier: str):
    contents = template.format(
        filename=os.path.basename(filepath),
        script=os.path.basename(__file__),
        deployment_name=deployment_name,
        build_identifier=build_identifier,
    )
    try:
        with open(filepath, "w") as f:
            f.write(contents)
    except Exception as ex:
        sys.exit(f"ERROR: failed to generate file '{filepath}': {ex}")


def main(args: argparse.Namespace):
    deployment_name = args.target

    if "FPRIME_PROJECT_ROOT" not in os.environ:
        sys.exit("ERROR: environment variable '$FPRIME_PROJECT_ROOT' is not set")
    project_root = get_project_root()

    build_identifier = get_build_identifier(project_root)
    generate_source(args.output_path, deployment_name, build_identifier)


if __name__ == "__main__":
    args = parse_args(sys.argv[1:])
    main(args)

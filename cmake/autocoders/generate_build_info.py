#!/usr/bin/env python3
# Copyright 2025 California Institute of Technology
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0

###############################################################################
# cmake/autocoders/generate_build_info.py
###############################################################################

import argparse
import os
import subprocess
import sys


# Build identifer is length limited to ensure that it's not truncated when reported
# via channelized telemetry and events
BUILD_ID_MAX_LEN = 49

# this is the template for the auto-generated CPP source file
# the output path for this file is set via command-line argument
template = """\
/*
** {filename}
** This file has been autogenerated using {script}
*/
#include <config/FppConstantsAc.hpp>
static_assert(FW_LOG_STRING_MAX_SIZE >= {BUILD_ID_MAX_LEN} && FW_TLM_STRING_MAX_SIZE >= {BUILD_ID_MAX_LEN},
     "generate_build_info.py BUILD_ID_MAX_LEN value is out of date");  

namespace Va416x0Svc {{
    namespace BuildInfo {{
        const char* DEPLOYMENT_NAME  = "{deployment_name}";
        const char* BUILD_IDENTIFIER = "{build_identifier}";
    }}
}}
"""


def parse_args(args: list[str]) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Generate deployment build information source files"
    )
    parser.add_argument(
        "target",
        help="Name of the CMake build target"
    )
    parser.add_argument(
        "output_path",
        help="Output path for the generated CPP file"
    )
    return parser.parse_args(args)


def get_project_root() -> str:
    if "FPRIME_PROJECT_ROOT" not in os.environ:
        sys.exit("ERROR: environment variable '$FPRIME_PROJECT_ROOT' is not set")
    return os.environ["FPRIME_PROJECT_ROOT"]


def get_date() -> str:
    output = subprocess.check_output(["date", "+%Y-%m-%d-%H-%M-%S"])
    return output.decode().strip()


def get_branch(project_root: str) -> str:
    output = subprocess.check_output(
        ["git", "branch", "--show-current"], cwd=project_root
    )
    branch = output.decode().strip()
    # if we are not currently on a branch (i.e. in a detached HEAD state) then fallback to the
    # current commit hash
    if not branch:
        output = subprocess.check_output(
            ["git", "rev-parse", "--short", "HEAD"], cwd=project_root
        )
        branch = output.decode().strip()
    return branch


def get_user() -> str:
    # First check if $DEVCONTAINER_HOST_USER is set, this is set for user-driven builds from
    # VS Code development containers where $USER instead defaults to root
    if "DEVCONTAINER_HOST_USER" in os.environ:
        return os.environ["DEVCONTAINER_HOST_USER"]
    # Fallback to $USER otherwise
    elif "USER" in os.environ:
        return os.environ["USER"]
    else:
        sys.exit(
            "ERROR: could not determine user, neither $DEVCONTAINER_HOST_USER nor $USER is set"
        )


def get_build_identifier(project_root: str) -> str:
    # $JENKINS_BUILD_ID can be set from the Jenkins environment to ensure unified identifiers
    # across Jenkins builds
    key = "JENKINS_BUILD_ID"
    if key in os.environ:
        value = os.environ[key]
        # If the version is set by an environment variable, assume the entire 
        # string is required to uniquely identify the build, and fatal if it 
        # would be truncated when reported in GDS
        if len(value) > BUILD_ID_MAX_LEN:
            sys.exit(
                f"ERROR: Value of {key} environment variable ({value!r}, length "
                f"{len(value)}) exceeds maximum build ID length ({BUILD_ID_MAX_LEN})\n"
            )
    else:
        # If the version is not set by an environment variable, the build ID
        # is less important so accept that the date, branch, and user (even
        # if some characters are truncated) is identification _enough_
        # The goal is to make life easier for developers, because GIT branch
        # names are often long enough that the build ID exceeds
        # BUILD_ID_MAX_LEN. Fataling on that requires either developers rename
        # the branches (and loose information there) or set the build ID via
        # environment variable (which also results in loss of information)
        date = get_date()
        branch = get_branch(project_root)
        user = get_user()
        value = f"{date}-{branch}-dev-{user}"[:BUILD_ID_MAX_LEN]
    return value


def generate_source(filepath: str, deployment_name: str, build_identifier: str):
    contents = template.format(
        filename=os.path.basename(filepath),
        script=os.path.basename(__file__),
        deployment_name=deployment_name,
        build_identifier=build_identifier,
        BUILD_ID_MAX_LEN=BUILD_ID_MAX_LEN,
    )
    try:
        with open(filepath, "w") as f:
            f.write(contents)
    except Exception as ex:
        sys.exit(f"ERROR: failed to generate file '{filepath}': {ex}")


def main(args: argparse.Namespace):
    deployment_name = args.target

    if "FPRIME_PROJECT_ROOT" not in os.environ:
        sys.exit("ERROR: environment variable '$FPRIME_PROJECT_ROOT' is not set")
    project_root = get_project_root()

    build_identifier = get_build_identifier(project_root)
    generate_source(args.output_path, deployment_name, build_identifier)


if __name__ == "__main__":
    args = parse_args(sys.argv[1:])
    main(args)
